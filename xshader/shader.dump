#version 120

uniform sampler2D gBuffer_Depth;
uniform sampler2D gBuffer_Color;
uniform sampler2D gBuffer_Normal;
uniform sampler2D gBuffer_Material;

uniform float textureSize;

uniform float depthRange_Near;
uniform float depthRange_Far;
uniform float depthRange_Diff;

struct Ray{
	vec3 pos;
	vec3 dir;
	vec3 color[1];
	vec3 finalColor;
	int start;
	int group;
	bool ok;
};

const int SAMPLES_PER_RAY = 2048;
const int MAX_RAYS = 2;
struct RayTracer{
	Ray rays[MAX_RAYS];
	int ray;
	Ray actualRay;
	int actualRayID;
}rayTracer;

void makeRays(in int groupID);

void calcColor(in int groupID);

void addRay(vec3 dir){
	if(rayTracer.ray<MAX_RAYS){
		rayTracer.rays[rayTracer.ray].pos = rayTracer.actualRay.pos;
		rayTracer.rays[rayTracer.ray].dir = dir;
		rayTracer.rays[rayTracer.ray].start = -1;
		rayTracer.rays[rayTracer.ray].group = -1;
		rayTracer.rays[rayTracer.ray].ok = false;
		rayTracer.ray++;
	}
}

vec4 getRayColor(int num){
	int s = rayTracer.actualRay.start+num;
	if(s<MAX_RAYS && rayTracer.rays[s].ok){
		return vec4(rayTracer.rays[s].finalColor, 1.0);
	}
	return vec4(1.0, 1.0, 1.0, 0.0);
}

vec2 getTexCoord(){
	return rayTracer.actualRay.pos.xy;
}

vec3 getNormal(){
	return texture2D(gBuffer_Normal, getTexCoord()).rgb*2.0-1.0;
}

/*
 * AUTOGENERATED
 */

void out_colorcalc_id1(in vec3 brdf){
rayTracer.actualRay.finalColor = brdf;
}

void diffuse_id2(in vec3 color, out vec3 color_calc_color){
color_calc_color = color;
}
void diffuse_colorcalc_id2(in vec3 color_calc_color, out vec3 brdf){
brdf = color_calc_color;
}

void color_mul_id3(in vec3 incolor, in float v, out vec3 color){
color = incolor*v;
}

void color_in_id4(out vec3 color){
color = texture2D(gBuffer_Color, getTexCoord()).rgb;
}

void glossy_id5(in vec3 color, in vec3 normal, out vec3 color_calc_color){
addRay(reflect(rayTracer.actualRay.dir, normalize(normal)));
color_calc_color = color;
}
void glossy_colorcalc_id5(in vec3 color_calc_color, out vec3 brdf){
vec4 rayColor = getRayColor(0);
brdf = rayColor.rgb*color_calc_color;
}

void material_mid0(){
vec3 var1_VEC3;
color_in_id4(var1_VEC3);
vec3 var2_VEC3;
color_mul_id3(var1_VEC3, 1.0, var2_VEC3);
diffuse_id2(var2_VEC3, rayTracer.actualRay.color[0]);
}

void material_colorcalc_mid0(){
vec3 var1_VEC3;
diffuse_colorcalc_id2(rayTracer.actualRay.color[0], var1_VEC3);
out_colorcalc_id1(var1_VEC3);
}

void material_mid1(){
vec3 var1_VEC3;
color_in_id4(var1_VEC3);
glossy_id5(var1_VEC3, getNormal(), rayTracer.actualRay.color[0]);
}

void material_colorcalc_mid1(){
vec3 var1_VEC3;
glossy_colorcalc_id5(rayTracer.actualRay.color[0], var1_VEC3);
out_colorcalc_id1(var1_VEC3);
}

void makeRays(in int groupID){
switch(groupID){
case 0:
material_mid0();
break;
case 1:
material_mid1();
break;
default:
break;
}
}

void calcColor(in int groupID){
switch(groupID){
case 0:
material_colorcalc_mid0();
break;
case 1:
material_colorcalc_mid1();
break;
default:
break;
}
}



/*
 * AUTOGENERATED END
 */

float linearizeDepth(float depth){
	return (2.0*depthRange_Near)/(depthRange_Far+depthRange_Near-depth*depthRange_Diff);
}

float getDepth(in vec2 pos){
	return linearizeDepth(texture2D(gBuffer_Depth, pos).x);
}

void calcPos(){
	vec3 pos = rayTracer.actualRay.pos;
	//vec4 mul = gl_ProjectionMatrix * vec4(rayTracer.actualRay.dir, 1.0);
	//vec3 dir = normalize(mul.xyz/mul.w);
	vec3 dir = rayTracer.actualRay.dir;
	float dirLength = length(dir.xy);
    dir /= dirLength * textureSize;
	//dir.z *= pos.z;
	
	int sample = 0;
	while(sample<SAMPLES_PER_RAY){
		float depth = getDepth(pos.xy);
        float difference = pos.z - depth;
        if(difference > 0 && difference<0.0005) {
        	rayTracer.actualRay.ok = true;
            break;
        }
		pos += dir;
		if(pos.x<0.0 || pos.x>1.0 || pos.y<0.0 || pos.y>1.0){// || pos.z>depthRange_Far || pos.z<depthRange_Near){
			break;
		}
		sample++;
	}
	
	rayTracer.actualRay.pos = pos;
}

void raySetup(){
	float group = texture2D(gBuffer_Material, getTexCoord()).r;
	rayTracer.actualRay.group = int(group);
	rayTracer.actualRay.finalColor = vec3(group, group, group);
	makeRays(rayTracer.actualRay.group);
}

void shootRay(){
	rayTracer.actualRay = rayTracer.rays[rayTracer.actualRayID];
	rayTracer.actualRay.start = rayTracer.ray;
	calcPos();
	if(rayTracer.actualRay.ok){
		raySetup();
	}
	rayTracer.rays[rayTracer.actualRayID] = rayTracer.actualRay;
}

void calcColor(){
	rayTracer.actualRay = rayTracer.rays[rayTracer.actualRayID];
	if(rayTracer.actualRay.ok){
		calcColor(rayTracer.actualRay.group);
		rayTracer.rays[rayTracer.actualRayID] = rayTracer.actualRay;
	}
}

void main(){
	float depth = texture2D(gBuffer_Depth, gl_TexCoord[0].xy).x;
	rayTracer.actualRayID = 0;
	rayTracer.actualRay.pos = vec3(gl_TexCoord[0].xy, linearizeDepth(depth));
	//vec4 viewDir = gl_ProjectionMatrixInverse * vec4(0.0, 0.0, 1.0, 1.0);
	rayTracer.actualRay.dir = vec3(0.0, 0.0, -1.0);//normalize(viewDir.xyz/viewDir.w);
	rayTracer.actualRay.start = 1;
	rayTracer.actualRay.group = -1;
	rayTracer.actualRay.ok = true;
	rayTracer.ray = 1;
	raySetup();
	rayTracer.rays[0] = rayTracer.actualRay;
	for(rayTracer.actualRayID = 1; rayTracer.actualRayID<rayTracer.ray; rayTracer.actualRayID++){
		shootRay();
	}
	for(rayTracer.actualRayID = rayTracer.ray-1; rayTracer.actualRayID>=0; rayTracer.actualRayID--){
		calcColor();
	}
	gl_FragColor = vec4(rayTracer.rays[0].finalColor, 1.0);
}

