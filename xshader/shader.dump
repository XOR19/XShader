#version 120

uniform sampler2D gBuffer_Depth;
uniform sampler2D gBuffer_Color;
uniform sampler2D gBuffer_Normal;
uniform sampler2D gBuffer_Material;

uniform float textureSize;
uniform vec2 textureScale;

uniform float depthRange_Near;
uniform float depthRange_Far;
uniform float depthRange_Diff;

varying mat4 gBufferMatrix;
varying mat4 gBufferMatrixInverse;


struct Ray{
	vec2 ssp;
	vec3 pos;
	vec3 dir;
	vec3 finalColor;
	int start;
	int group;
	bool ok;
	vec3 color[1];
};

const int SAMPLES_PER_RAY = 2048;
const int MAX_RAYS = 3;
struct RayTracer{
	Ray rays[MAX_RAYS];
	int ray;
	Ray actualRay;
	int actualRayID;
}rayTracer;

void makeRays(in int groupID);

void calcColor(in int groupID);

void addRay(vec3 dir){
	if(rayTracer.ray<MAX_RAYS){
		rayTracer.rays[rayTracer.ray].ssp = rayTracer.actualRay.ssp;
		rayTracer.rays[rayTracer.ray].pos = rayTracer.actualRay.pos;
		rayTracer.rays[rayTracer.ray].dir = dir;
		rayTracer.rays[rayTracer.ray].start = -1;
		rayTracer.rays[rayTracer.ray].group = -1;
		rayTracer.rays[rayTracer.ray].ok = false;
		rayTracer.ray++;
	}
}

vec4 getRayColor(int num){
	int s = rayTracer.actualRay.start+num;
	if(s<MAX_RAYS && rayTracer.rays[s].ok){
		return vec4(rayTracer.rays[s].finalColor, 1.0);
	}
	return vec4(1.0, 1.0, 1.0, 0.0);
}

vec2 getTexCoord(){
	return rayTracer.actualRay.ssp*textureScale;
}

vec3 getNormal(){
	return texture2D(gBuffer_Normal, getTexCoord()).rgb*2.0-1.0;
}

float linearizeDepth(float depth){
	return (2.0*depthRange_Near)/(depthRange_Far+depthRange_Near-depth*depthRange_Diff);
}

float getDepth(in vec2 pos){
	return linearizeDepth(texture2D(gBuffer_Depth, pos*textureScale).x);
}

vec3 screenSpace2WorldSpace(vec2 pos){
	float depth = texture2D(gBuffer_Depth, pos*textureScale).x;
	vec4 vec = gl_ProjectionMatrixInverse*vec4((pos.x*2.0)-1.0, (pos.y*2.0)-1.0, (depth*2.0)-1.0, 1.0);
	return vec.xyz/vec.w;
}

vec3 worldSpace2ScreenSpace(vec3 pos){
	vec4 vec = gl_ProjectionMatrix*vec4(pos, 1.0);
	vec3 v3 = vec.xyz/vec.w;
	return (v3+1.0)/2.0;
}

/*
 * AUTOGENERATED
 */

void out_colorcalc_id1(in vec3 brdf){
rayTracer.actualRay.finalColor = brdf;
}

void diffuse_id2(in vec3 color, out vec3 color_calc_color){
color_calc_color = color;
}
void diffuse_colorcalc_id2(in vec3 color_calc_color, out vec3 brdf){
brdf = color_calc_color;
}

void color_mul_id3(in vec3 incolor, in float v, out vec3 color){
color = incolor*v;
}

void color_in_id4(out vec3 color){
color = texture2D(gBuffer_Color, getTexCoord()).rgb;
}

void glossy_id5(in vec3 color, in vec3 normal, out vec3 color_calc_color){
addRay(reflect(rayTracer.actualRay.dir, normalize(normal)));
color_calc_color = color;
}
void glossy_colorcalc_id5(in vec3 color_calc_color, out vec3 brdf){
vec4 rayColor = getRayColor(0);
brdf = rayColor.rgb*color_calc_color;
}

void material_mid0(){
vec3 var1_VEC3;
color_in_id4(var1_VEC3);
vec3 var2_VEC3;
color_mul_id3(var1_VEC3, 1.0, var2_VEC3);
diffuse_id2(var2_VEC3, rayTracer.actualRay.color[0]);
}

void material_colorcalc_mid0(){
vec3 var1_BRDF;
diffuse_colorcalc_id2(rayTracer.actualRay.color[0], var1_BRDF);
out_colorcalc_id1(var1_BRDF);
}

void material_mid1(){
vec3 var1_VEC3;
color_in_id4(var1_VEC3);
glossy_id5(var1_VEC3, getNormal(), rayTracer.actualRay.color[0]);
}

void material_colorcalc_mid1(){
vec3 var1_BRDF;
glossy_colorcalc_id5(rayTracer.actualRay.color[0], var1_BRDF);
out_colorcalc_id1(var1_BRDF);
}

void makeRays(in int groupID){
switch(groupID){
case 0:
material_mid0();
break;
case 1:
material_mid1();
break;
default:
break;
}
}

void calcColor(in int groupID){
switch(groupID){
case 0:
material_colorcalc_mid0();
break;
case 1:
material_colorcalc_mid1();
break;
default:
break;
}
}



/*
 * AUTOGENERATED END
 */

void calcPos(){
	vec3 pos = rayTracer.actualRay.pos;
	vec3 dir = rayTracer.actualRay.dir;
	vec3 ssp;
	float dirLength = length(dir.xy);
    dir /= dirLength * 100;
	pos += dir;
	int sample = 0;
	while(sample<SAMPLES_PER_RAY){
		ssp = worldSpace2ScreenSpace(pos);
		if(ssp.x<0.0 || ssp.x>1.0 || ssp.y<0.0 || ssp.y>1.0 || ssp.z>1.0 || ssp.z<0.0){
			break;
		}
		float depth = getDepth(ssp.xy);
        float difference = linearizeDepth(ssp.z) - depth;
        if(difference > 0 && difference<0.0005) {
        	rayTracer.actualRay.ok = true;
            break;
        }
		pos += dir;
		sample++;
	}
	rayTracer.actualRay.ssp = ssp.xy;
	rayTracer.actualRay.pos = pos;
}

void raySetup(){
	float group = texture2D(gBuffer_Material, getTexCoord()).r;
	rayTracer.actualRay.group = int(group);
	rayTracer.actualRay.finalColor = vec3(group, group, group);
	makeRays(rayTracer.actualRay.group);
}

void shootRay(){
	rayTracer.actualRay = rayTracer.rays[rayTracer.actualRayID];
	rayTracer.actualRay.start = rayTracer.ray;
	calcPos();
	if(rayTracer.actualRay.ok){
		raySetup();
	}
	rayTracer.rays[rayTracer.actualRayID] = rayTracer.actualRay;
}

void calcColor(){
	rayTracer.actualRay = rayTracer.rays[rayTracer.actualRayID];
	if(rayTracer.actualRay.ok){
		calcColor(rayTracer.actualRay.group);
		rayTracer.rays[rayTracer.actualRayID] = rayTracer.actualRay;
	}
}

void main(){
	rayTracer.actualRayID = 0;
	rayTracer.actualRay.ssp = gl_TexCoord[0].xy;
	rayTracer.actualRay.pos = screenSpace2WorldSpace(gl_TexCoord[0].xy);
	rayTracer.actualRay.dir = normalize(rayTracer.actualRay.pos);
	rayTracer.actualRay.start = 1;
	rayTracer.actualRay.group = -1;
	rayTracer.actualRay.ok = true;
	rayTracer.ray = 1;
	raySetup();
	rayTracer.rays[0] = rayTracer.actualRay;
	for(rayTracer.actualRayID = 1; rayTracer.actualRayID<rayTracer.ray; rayTracer.actualRayID++){
		shootRay();
	}
	for(rayTracer.actualRayID = rayTracer.ray-1; rayTracer.actualRayID>=0; rayTracer.actualRayID--){
		calcColor();
	}
	gl_FragColor = vec4(rayTracer.rays[0].finalColor, 1.0);
}

